<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tropical Island Paradise</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.70.0/phaser.min.js"></script>
  <style>
    body{margin:0;padding:20px;background:linear-gradient(135deg,#87CEEB 0%,#4682B4 100%);display:flex;justify-content:center;align-items:center;min-height:100vh;font-family:Arial,sans-serif}
    #game-container{border:4px solid #2E86AB;border-radius:15px;box-shadow:0 15px 35px rgba(0,0,0,.4);overflow:hidden;position:relative}
    .loading-overlay{position:absolute;inset:0;background:linear-gradient(135deg,rgba(135,206,235,.95),rgba(70,130,180,.95));display:flex;flex-direction:column;justify-content:center;align-items:center;z-index:1000;transition:all .6s ease-out}
    .loading-text{color:#fff;font-size:28px;font-weight:bold;text-shadow:3px 3px 6px rgba(0,0,0,.7);margin-bottom:25px;animation:pulse 2s infinite}
    @keyframes pulse{0%,100%{opacity:1}50%{opacity:.7}}
    .loading-bar{width:350px;height:25px;background:rgba(255,255,255,.3);border-radius:15px;border:3px solid #fff;box-shadow:0 4px 8px rgba(0,0,0,.3);overflow:hidden}
    .loading-progress{height:100%;background:linear-gradient(90deg,#32CD32,#228B22,#90EE90);width:0%;transition:width .4s ease;border-radius:12px}
    .status-info{margin-top:20px;color:rgba(255,255,255,.9);font-size:16px;text-shadow:1px 1px 2px rgba(0,0,0,.5)}
  </style>
</head>
<body>
  <div id="game-container">
    <div class="loading-overlay" id="loading-overlay">
      <div class="loading-text" id="loading-text">üèùÔ∏è Loading Tropical Paradise...</div>
      <div class="loading-bar"><div class="loading-progress" id="loading-progress"></div></div>
      <div class="status-info" id="status-info">Fetching assets from GitHub Pages...</div>
    </div>
  </div>

  <script>
  // ===== CONSTANTS =====
  const GAME_WIDTH = 800;
  const GAME_HEIGHT = 600;
  const COLORS = {
    SKY: 0x87CEEB,
    WHITE: 0xFFFFFF,
    BLACK: 0x000000,
    BLUE: 0x2E86AB,
    GREEN: 0x32CD32,
    RED: 0xFF6B6B,
    YELLOW: 0xFFD700
  };

  // Fish types that can be caught (expanded and normalized)
  const FISH_TYPES = [
    {id: 'fish_blue', displayName: 'Blue Fish', rarity: 'Common'},
    {id: 'fish_yellow', displayName: 'Yellow Fish', rarity: 'Common'},
    {id: 'fish_orange', displayName: 'Orange Fish', rarity: 'Common'},
    {id: 'fish_red', displayName: 'Red Fish', rarity: 'Uncommon'},
    {id: 'fish_green', displayName: 'Green Fish', rarity: 'Uncommon'},
    {id: 'fish_purple', displayName: 'Purple Fish', rarity: 'Rare'},
    {id: 'fish_gray', displayName: 'Gray Fish', rarity: 'Uncommon'},
    {id: 'fish_spotted', displayName: 'Spotted Fish', rarity: 'Rare'},
    {id: 'angelfish', displayName: 'Angelfish', rarity: 'Rare'},
    {id: 'fish_shark_small', displayName: 'Small Shark', rarity: 'Epic'},
    {id: 'octopus_orange', displayName: 'Orange Octopus', rarity: 'Epic'},
    {id: 'crab_blue', displayName: 'Blue Crab', rarity: 'Uncommon'}
  ];

  // ===== GAME STATE MANAGER =====
  const GameState = {
    fishCollection: null,
    debugMode: false,
    currentFishingGame: null, // Track active fishing game for drift mechanic

    init() {
      this.fishCollection = new FishCollection();
      this.fishCollection.load();
    }
  };

  // ===== FISH COLLECTION MANAGER =====
  class FishCollection {
    constructor() {
      this.collection = {}; // id -> {seen, caught, count}
      this.storageKey = 'maxisIsland.collection.v1';

      // Initialize all fish as unseen
      FISH_TYPES.forEach(fish => {
        this.collection[fish.id] = {
          seen: false,
          caught: false,
          count: 0
        };
      });
    }

    // Mark a fish as caught
    catchFish(fishId) {
      if (!this.collection[fishId]) {
        console.warn(`Unknown fish: ${fishId}`);
        return false;
      }

      const wasNew = !this.collection[fishId].caught;
      this.collection[fishId].seen = true;
      this.collection[fishId].caught = true;
      this.collection[fishId].count++;

      this.save();
      return wasNew; // Return true if this is the first time catching this fish
    }

    // Get fish data
    getFishData(fishId) {
      return this.collection[fishId] || {seen: false, caught: false, count: 0};
    }

    // Get all fish with their collection status
    getAllFish() {
      return FISH_TYPES.map(fish => ({
        ...fish,
        ...this.collection[fish.id]
      }));
    }

    // Get statistics
    getStats() {
      const total = FISH_TYPES.length;
      const caught = Object.values(this.collection).filter(f => f.caught).length;
      const totalCatches = Object.values(this.collection).reduce((sum, f) => sum + f.count, 0);

      return { total, caught, totalCatches };
    }

    // Save to localStorage
    save() {
      try {
        localStorage.setItem(this.storageKey, JSON.stringify(this.collection));
      } catch (e) {
        console.error('Failed to save collection:', e);
      }
    }

    // Load from localStorage
    load() {
      try {
        const saved = localStorage.getItem(this.storageKey);
        if (saved) {
          const loaded = JSON.parse(saved);
          // Merge saved data with current collection (handles new fish being added)
          Object.keys(loaded).forEach(fishId => {
            if (this.collection[fishId]) {
              this.collection[fishId] = loaded[fishId];
            }
          });
          console.log('‚úÖ Collection loaded from storage');
        }
      } catch (e) {
        console.error('Failed to load collection, starting fresh:', e);
      }
    }

    // Reset collection (for testing)
    reset() {
      FISH_TYPES.forEach(fish => {
        this.collection[fish.id] = {seen: false, caught: false, count: 0};
      });
      this.save();
    }
  }

  // ===== MAIN GAME SCENE =====
  class TropicalIslandScene extends Phaser.Scene {
    constructor() {
      super('TropicalIslandScene');
      this.fishingMinigame = null;
      this.collectionPanel = null;
      this.debugPanel = null;
    }

    preload() {
      // Use relative paths - works locally AND on GitHub Pages
      this.load.atlas('terrain', 'terrain_flora.png', 'terrain_flora.json');
      this.load.atlas('fish', 'fish_characters.png', 'fish_characters.json');

      // Progress bar feedback
      const bar = document.getElementById('loading-progress');
      const txt = document.getElementById('loading-text');
      const info = document.getElementById('status-info');

      this.load.on('progress', v => {
        bar.style.width = `${v * 100}%`;
        txt.textContent = `üèùÔ∏è Loading... ${Math.round(v * 100)}%`;
        console.log(`Loading progress: ${Math.round(v * 100)}%`);
      });

      this.load.on('fileload', (_, __, ___, f) => {
        const filename = f.url.split('/').pop();
        info.textContent = `‚úÖ Loaded: ${filename}`;
        console.log(`‚úÖ Successfully loaded: ${filename}`);
      });

      this.load.on('complete', () => {
        info.textContent = 'üéâ All assets loaded!';
        console.log('üéâ All assets loaded successfully!');
        setTimeout(() => document.getElementById('loading-overlay').style.display = 'none', 600);
      });

      this.load.on('loaderror', f => {
        const filename = f.url.split('/').pop();
        txt.textContent = '‚ùå Load error';
        info.textContent = `Failed: ${filename}`;
        info.style.color = '#ff6b6b';
        console.error(`‚ùå Failed to load: ${filename}`, f.url);
      });
    }

    create() {
      console.log('üéÆ Creating game scene...');

      // Initialize game state
      GameState.init();

      // Verify atlases loaded
      if (!this.textures.exists('terrain') || !this.textures.exists('fish')) {
        console.error('‚ùå Atlases not loaded!');
        this.add.text(GAME_WIDTH / 2, GAME_HEIGHT / 2, 'ERROR: Failed to load assets', {
          fontSize: '24px',
          fill: '#ff0000'
        }).setOrigin(0.5);
        return;
      }

      // Sky background
      this.add.rectangle(GAME_WIDTH / 2, GAME_HEIGHT / 2, GAME_WIDTH, GAME_HEIGHT, COLORS.SKY);

      // Create island scenery
      this.createIsland();

      // Create animated water effects
      this.createWaterEffects();

      // Create swimming fish
      this.createSwimmingFish();

      // Create fishing spot
      this.createFishingSpot();

      // Title
      this.add.text(GAME_WIDTH / 2, 50, 'üå¥ MAXI\'S ISLAND FISHING üå¥', {
        fontSize: '32px',
        fontFamily: 'Arial',
        fill: '#fff',
        stroke: '#2E86AB',
        strokeThickness: 6
      }).setOrigin(0.5);

      // Instructions
      const instructions = this.add.text(GAME_WIDTH / 2, GAME_HEIGHT - 30,
        'Click fishing spot to fish | Press C for Collection | Press D for Debug', {
        fontSize: '14px',
        fill: '#fff',
        stroke: '#2E86AB',
        strokeThickness: 3
      }).setOrigin(0.5);

      // Keyboard shortcuts
      this.input.keyboard.on('keydown-C', () => this.toggleCollectionPanel());
      this.input.keyboard.on('keydown-D', () => this.toggleDebugPanel());

      console.log('‚úÖ Scene creation complete!');
      console.log('üìä Collection stats:', GameState.fishCollection.getStats());
    }

    createIsland() {
      // Sand island base
      const sand = this.add.image(380, 340, 'terrain', 'sand_irregular').setScale(2.5);

      // Palm trees
      const palm1 = this.add.image(300, 260, 'terrain', 'palm_big')
        .setScale(1.8)
        .setOrigin(0.5, 1);
      const palm2 = this.add.image(500, 280, 'terrain', 'palm_small')
        .setScale(2.0)
        .setOrigin(0.5, 1);

      // Bushes
      const bush = this.add.image(420, 320, 'terrain', 'bush_medium').setScale(1.8);

      // Animate palms swaying
      this.tweens.add({
        targets: palm1,
        rotation: 0.18,
        duration: 4000,
        yoyo: true,
        repeat: -1,
        ease: 'Sine.easeInOut'
      });

      this.tweens.add({
        targets: palm2,
        rotation: -0.15,
        duration: 4500,
        yoyo: true,
        repeat: -1,
        ease: 'Sine.easeInOut',
        delay: 1500
      });

      console.log('‚úÖ Island created');
    }

    createWaterEffects() {
      // Waves at different depths
      const wave1 = this.add.image(150, 480, 'terrain', 'wave_shallow')
        .setScale(2)
        .setAlpha(0.6);
      const wave2 = this.add.image(600, 500, 'terrain', 'wave_shallow')
        .setScale(2)
        .setAlpha(0.6);

      // Animate waves
      this.tweens.add({
        targets: [wave1, wave2],
        x: '+=20',
        duration: 3000,
        yoyo: true,
        repeat: -1,
        ease: 'Sine.easeInOut'
      });

      console.log('‚úÖ Water effects created');
    }

    createSwimmingFish() {
      // Background fish swimming around
      const fish1 = this.add.image(150, 200, 'fish', 'fish_blue').setScale(3.5);
      const fish2 = this.add.image(650, 450, 'fish', 'fish_yellow').setScale(3.2);

      // Animate fish swimming
      this.tweens.add({
        targets: fish1,
        x: 250,
        y: 170,
        duration: 7000,
        yoyo: true,
        repeat: -1,
        ease: 'Sine.easeInOut'
      });

      this.tweens.add({
        targets: fish2,
        x: 550,
        y: 480,
        duration: 8000,
        yoyo: true,
        repeat: -1,
        ease: 'Sine.easeInOut',
        delay: 2000
      });

      console.log('‚úÖ Swimming fish created');
    }

    createFishingSpot() {
      // Fishing spot indicator
      const fishingX = 100;
      const fishingY = 380;

      // Visual indicator - log/dock
      const dock = this.add.image(fishingX, fishingY, 'terrain', 'log_large')
        .setScale(1.5)
        .setAlpha(0.9);

      // Interactive area
      const clickArea = this.add.circle(fishingX, fishingY, 50, COLORS.BLUE, 0.3)
        .setInteractive({ useHandCursor: true })
        .setStrokeStyle(3, COLORS.WHITE);

      // Hover effect
      clickArea.on('pointerover', () => {
        clickArea.setFillStyle(COLORS.BLUE, 0.5);
        this.tweens.add({
          targets: clickArea,
          scale: 1.1,
          duration: 200
        });
      });

      clickArea.on('pointerout', () => {
        clickArea.setFillStyle(COLORS.BLUE, 0.3);
        this.tweens.add({
          targets: clickArea,
          scale: 1.0,
          duration: 200
        });
      });

      // Start fishing on click
      clickArea.on('pointerdown', () => {
        this.startFishing();
      });

      // Floating prompt
      const prompt = this.add.text(fishingX, fishingY - 60, 'üé£', {
        fontSize: '32px'
      }).setOrigin(0.5);

      // Animate prompt
      this.tweens.add({
        targets: prompt,
        y: fishingY - 70,
        duration: 1000,
        yoyo: true,
        repeat: -1,
        ease: 'Sine.easeInOut'
      });

      console.log('‚úÖ Fishing spot created');
    }

    startFishing() {
      if (this.fishingMinigame) return; // Already fishing

      console.log('üé£ Starting fishing mini-game...');
      this.fishingMinigame = new FishingMinigame(this, this.onFishingComplete.bind(this));
    }

    onFishingComplete(success, caughtFish) {
      this.fishingMinigame = null;

      if (success && caughtFish) {
        console.log(`üéâ Caught a ${caughtFish.displayName}!`);

        // Add to collection
        const wasNew = GameState.fishCollection.catchFish(caughtFish.id);

        // Show "New Fish!" popup if first time
        if (wasNew) {
          this.showNewFishPopup(caughtFish);
        }
      } else {
        console.log('üò¢ The fish got away...');
      }
    }

    showNewFishPopup(fish) {
      // Create a temporary popup for new fish discovery
      const container = this.add.container(0, 0).setDepth(200);

      const overlay = this.add.rectangle(0, 0, GAME_WIDTH, GAME_HEIGHT, COLORS.BLACK, 0.8)
        .setOrigin(0);
      container.add(overlay);

      const panelWidth = 400;
      const panelHeight = 300;
      const centerX = GAME_WIDTH / 2;
      const centerY = GAME_HEIGHT / 2;

      // GameBoy style panel
      const outerBorder = this.add.rectangle(centerX, centerY, panelWidth + 20, panelHeight + 20, COLORS.WHITE)
        .setStrokeStyle(4, COLORS.BLACK);
      container.add(outerBorder);

      const panel = this.add.rectangle(centerX, centerY, panelWidth, panelHeight, 0x9BBC0F)
        .setStrokeStyle(4, 0x0F380F);
      container.add(panel);

      // "NEW!" text
      const newText = this.add.text(centerX, centerY - 110, 'üéâ NEW FISH! üéâ', {
        fontSize: '28px',
        fontFamily: 'Arial',
        fill: '#0F380F',
        fontStyle: 'bold'
      }).setOrigin(0.5);
      container.add(newText);

      // Fish sprite
      const fishSprite = this.add.image(centerX, centerY - 20, 'fish', fish.id)
        .setScale(6);
      container.add(fishSprite);

      // Fish name
      const nameText = this.add.text(centerX, centerY + 60, fish.displayName, {
        fontSize: '24px',
        fontFamily: 'Arial',
        fill: '#0F380F',
        fontStyle: 'bold'
      }).setOrigin(0.5);
      container.add(nameText);

      // Rarity
      const rarityText = this.add.text(centerX, centerY + 90, `[${fish.rarity}]`, {
        fontSize: '18px',
        fontFamily: 'Arial',
        fill: '#0F380F',
        fontStyle: 'italic'
      }).setOrigin(0.5);
      container.add(rarityText);

      // Continue prompt
      const continueText = this.add.text(centerX, centerY + 120, 'Press SPACE to continue', {
        fontSize: '16px',
        fontFamily: 'Arial',
        fill: '#0F380F'
      }).setOrigin(0.5);
      container.add(continueText);

      // Pulse animation
      this.tweens.add({
        targets: fishSprite,
        scale: 7,
        duration: 500,
        yoyo: true,
        repeat: -1,
        ease: 'Sine.easeInOut'
      });

      // Close on space or click
      const closePopup = () => {
        this.input.keyboard.off('keydown-SPACE', closePopup);
        this.input.off('pointerdown', closePopup);
        container.destroy();
      };

      this.input.keyboard.once('keydown-SPACE', closePopup);
      this.input.once('pointerdown', closePopup);
    }

    toggleCollectionPanel() {
      if (this.collectionPanel) {
        // Close panel
        this.collectionPanel.destroy();
        this.collectionPanel = null;
      } else {
        // Open panel
        this.showCollectionPanel();
      }
    }

    showCollectionPanel() {
      const container = this.add.container(0, 0).setDepth(150);
      this.collectionPanel = container;

      // Overlay
      const overlay = this.add.rectangle(0, 0, GAME_WIDTH, GAME_HEIGHT, COLORS.BLACK, 0.8)
        .setOrigin(0)
        .setInteractive(); // Block clicks to game behind
      container.add(overlay);

      const panelWidth = 700;
      const panelHeight = 500;
      const centerX = GAME_WIDTH / 2;
      const centerY = GAME_HEIGHT / 2;

      // GameBoy style panel
      const outerBorder = this.add.rectangle(centerX, centerY, panelWidth + 20, panelHeight + 20, COLORS.WHITE)
        .setStrokeStyle(4, COLORS.BLACK);
      container.add(outerBorder);

      const panel = this.add.rectangle(centerX, centerY, panelWidth, panelHeight, 0x9BBC0F)
        .setStrokeStyle(4, 0x0F380F);
      container.add(panel);

      // Title
      const title = this.add.text(centerX, centerY - 220, 'üêü FISH COLLECTION üêü', {
        fontSize: '28px',
        fontFamily: 'Arial',
        fill: '#0F380F',
        fontStyle: 'bold'
      }).setOrigin(0.5);
      container.add(title);

      // Stats
      const stats = GameState.fishCollection.getStats();
      const statsText = this.add.text(centerX, centerY - 185,
        `Caught: ${stats.caught}/${stats.total} | Total Catches: ${stats.totalCatches}`, {
        fontSize: '16px',
        fontFamily: 'Arial',
        fill: '#0F380F'
      }).setOrigin(0.5);
      container.add(statsText);

      // Fish grid
      const allFish = GameState.fishCollection.getAllFish();
      const startX = centerX - 320;
      const startY = centerY - 150;
      const cols = 4;
      const cellWidth = 160;
      const cellHeight = 90;

      allFish.forEach((fish, index) => {
        const col = index % cols;
        const row = Math.floor(index / cols);
        const x = startX + col * cellWidth;
        const y = startY + row * cellHeight;

        // Background for each cell
        const cellBg = this.add.rectangle(x, y, cellWidth - 10, cellHeight - 10, 0x8BAC0F, 0.5)
          .setStrokeStyle(2, 0x0F380F);
        container.add(cellBg);

        if (fish.caught) {
          // Show fish sprite
          const sprite = this.add.image(x - 50, y, 'fish', fish.id).setScale(3);
          container.add(sprite);

          // Name
          const name = this.add.text(x + 10, y - 15, fish.displayName, {
            fontSize: '12px',
            fontFamily: 'Arial',
            fill: '#0F380F',
            fontStyle: 'bold',
            wordWrap: { width: 90 }
          }).setOrigin(0, 0.5);
          container.add(name);

          // Rarity and count
          const info = this.add.text(x + 10, y + 10, `${fish.rarity}\nx${fish.count}`, {
            fontSize: '10px',
            fontFamily: 'Arial',
            fill: '#0F380F'
          }).setOrigin(0, 0.5);
          container.add(info);
        } else {
          // Show silhouette/unknown
          const unknown = this.add.text(x, y, '???', {
            fontSize: '32px',
            fontFamily: 'Arial',
            fill: '#0F380F',
            alpha: 0.3
          }).setOrigin(0.5);
          container.add(unknown);
        }
      });

      // Close button
      const closeBtn = this.add.rectangle(centerX, centerY + 210, 200, 40, 0x0F380F)
        .setInteractive({ useHandCursor: true });
      container.add(closeBtn);

      const closeBtnText = this.add.text(centerX, centerY + 210, 'CLOSE (C)', {
        fontSize: '20px',
        fontFamily: 'Arial',
        fill: '#9BBC0F',
        fontStyle: 'bold'
      }).setOrigin(0.5);
      container.add(closeBtnText);

      closeBtn.on('pointerover', () => closeBtn.setFillStyle(0x8BAC0F));
      closeBtn.on('pointerout', () => closeBtn.setFillStyle(0x0F380F));
      closeBtn.on('pointerdown', () => this.toggleCollectionPanel());
    }

    toggleDebugPanel() {
      if (this.debugPanel) {
        this.debugPanel.destroy();
        this.debugPanel = null;
      } else {
        this.showDebugPanel();
      }
    }

    showDebugPanel() {
      const container = this.add.container(0, 0).setDepth(200);
      this.debugPanel = container;

      // Overlay
      const overlay = this.add.rectangle(0, 0, GAME_WIDTH, GAME_HEIGHT, COLORS.BLACK, 0.9)
        .setOrigin(0)
        .setInteractive();
      container.add(overlay);

      // Title
      const title = this.add.text(GAME_WIDTH / 2, 30, 'SPRITE ATLAS DEBUGGER (Press D to close)', {
        fontSize: '20px',
        fontFamily: 'Arial',
        fill: '#ffffff',
        fontStyle: 'bold'
      }).setOrigin(0.5);
      container.add(title);

      // Show terrain atlas
      this.addAtlasPreview(container, 'terrain', 50, 60);

      // Show fish atlas
      this.addAtlasPreview(container, 'fish', 430, 60);

      // Instructions
      const instructions = this.add.text(GAME_WIDTH / 2, GAME_HEIGHT - 20,
        'Check if sprites are cut off or misaligned', {
        fontSize: '14px',
        fontFamily: 'Arial',
        fill: '#ffff00'
      }).setOrigin(0.5);
      container.add(instructions);
    }

    addAtlasPreview(container, atlasKey, startX, startY) {
      const atlas = this.textures.get(atlasKey);
      const frames = atlas.getFrameNames();

      // Header
      const header = this.add.text(startX, startY, `${atlasKey.toUpperCase()} (${frames.length} frames)`, {
        fontSize: '16px',
        fontFamily: 'Arial',
        fill: '#00ff00',
        fontStyle: 'bold'
      });
      container.add(header);

      // Grid of sprites
      const cols = 5;
      const cellSize = 60;
      let y = startY + 30;

      frames.forEach((frameName, index) => {
        const col = index % cols;
        const row = Math.floor(index / cols);
        const x = startX + col * cellSize;
        const cellY = y + row * (cellSize + 15);

        // Background
        const bg = this.add.rectangle(x + cellSize/2, cellY + cellSize/2, cellSize - 2, cellSize - 2, 0x333333)
          .setStrokeStyle(1, 0x666666);
        container.add(bg);

        // Sprite
        try {
          const sprite = this.add.image(x + cellSize/2, cellY + cellSize/2, atlasKey, frameName);

          // Scale to fit
          const scale = Math.min((cellSize - 10) / sprite.width, (cellSize - 10) / sprite.height);
          sprite.setScale(scale);

          container.add(sprite);
        } catch (e) {
          // If sprite fails, show error
          const error = this.add.text(x + cellSize/2, cellY + cellSize/2, 'X', {
            fontSize: '20px',
            fill: '#ff0000'
          }).setOrigin(0.5);
          container.add(error);
        }

        // Label
        const label = this.add.text(x + cellSize/2, cellY + cellSize + 5, frameName, {
          fontSize: '8px',
          fontFamily: 'Arial',
          fill: '#ffffff',
          wordWrap: { width: cellSize }
        }).setOrigin(0.5, 0);
        container.add(label);
      });
    }
  }

  // ===== FISHING MINI-GAME =====
  class FishingMinigame {
    constructor(scene, onComplete) {
      this.scene = scene;
      this.onComplete = onComplete;
      this.container = null;
      this.state = 'waiting'; // waiting, hooking, reeling, success, fail
      this.hookTimer = null;
      this.targetArrow = null;
      this.playerArrow = null;
      this.targetPosition = 0;
      this.playerPosition = 0;
      this.reelingTime = 0;
      this.maxReelingTime = 3000; // 3 seconds to reel in
      this.selectedFish = null;

      this.create();
    }

    create() {
      const centerX = GAME_WIDTH / 2;
      const centerY = GAME_HEIGHT / 2;

      // Container for entire mini-game
      this.container = this.scene.add.container(0, 0);
      this.container.setDepth(100);

      // Semi-transparent overlay
      const overlay = this.scene.add.rectangle(0, 0, GAME_WIDTH, GAME_HEIGHT, COLORS.BLACK, 0.7)
        .setOrigin(0);
      this.container.add(overlay);

      // GameBoy-style window
      const windowWidth = 500;
      const windowHeight = 350;

      // White outer border (GameBoy style)
      const outerBorder = this.scene.add.rectangle(centerX, centerY, windowWidth + 20, windowHeight + 20, COLORS.WHITE)
        .setStrokeStyle(4, COLORS.BLACK);
      this.container.add(outerBorder);

      // Inner window
      const window = this.scene.add.rectangle(centerX, centerY, windowWidth, windowHeight, 0x9BBC0F)
        .setStrokeStyle(4, 0x0F380F);
      this.container.add(window);

      // Title bar
      const titleBg = this.scene.add.rectangle(centerX, centerY - 140, windowWidth - 20, 50, 0x0F380F);
      this.container.add(titleBg);

      const title = this.scene.add.text(centerX, centerY - 140, 'üé£ FISHING MINI-GAME', {
        fontSize: '24px',
        fontFamily: 'Arial',
        fill: '#9BBC0F',
        fontStyle: 'bold'
      }).setOrigin(0.5);
      this.container.add(title);

      // Instructions text
      this.instructionText = this.scene.add.text(centerX, centerY - 80, 'Wait for the fish to bite...', {
        fontSize: '18px',
        fontFamily: 'Arial',
        fill: '#0F380F'
      }).setOrigin(0.5);
      this.container.add(this.instructionText);

      // Fishing rod visual
      const rod = this.scene.add.rectangle(centerX - 100, centerY - 20, 8, 120, 0x8B4513);
      this.container.add(rod);

      // Fishing line
      this.fishingLine = this.scene.add.line(0, centerX - 100, centerY + 40, centerX + 50, centerY + 60, 0x0F380F)
        .setLineWidth(2);
      this.container.add(this.fishingLine);

      // Hook
      this.hook = this.scene.add.circle(centerX + 50, centerY + 60, 8, COLORS.BLACK);
      this.container.add(this.hook);

      // Arrow UI container (hidden initially)
      this.arrowContainer = this.scene.add.container(centerX, centerY + 60);
      this.arrowContainer.setVisible(false);
      this.container.add(this.arrowContainer);

      // Create arrow track
      const trackWidth = 300;
      const track = this.scene.add.rectangle(0, 0, trackWidth, 60, 0x0F380F);
      this.arrowContainer.add(track);

      const trackInner = this.scene.add.rectangle(0, 0, trackWidth - 8, 52, 0x8BAC0F);
      this.arrowContainer.add(trackInner);

      // Target zone (changes position)
      this.targetZone = this.scene.add.rectangle(0, 0, 50, 52, COLORS.GREEN, 0.5)
        .setStrokeStyle(3, COLORS.GREEN);
      this.arrowContainer.add(this.targetZone);

      // Player arrow (you control this)
      this.playerArrow = this.scene.add.triangle(0, 0, 0, -20, -15, 20, 15, 20, COLORS.RED);
      this.arrowContainer.add(this.playerArrow);

      // Progress bar for reeling
      this.progressBar = this.scene.add.rectangle(centerX, centerY + 130, 0, 20, COLORS.GREEN)
        .setOrigin(0, 0.5);
      this.progressBar.setVisible(false);
      this.container.add(this.progressBar);

      // Result fish display
      this.resultFish = this.scene.add.image(centerX, centerY + 20, 'fish', 'fish_blue')
        .setScale(5)
        .setVisible(false);
      this.container.add(this.resultFish);

      // Close button (only shows after completion)
      this.closeButton = this.scene.add.rectangle(centerX, centerY + 130, 150, 40, 0x0F380F)
        .setInteractive({ useHandCursor: true })
        .setVisible(false);
      this.container.add(this.closeButton);

      const closeText = this.scene.add.text(centerX, centerY + 130, 'CLOSE', {
        fontSize: '20px',
        fill: '#9BBC0F',
        fontStyle: 'bold'
      }).setOrigin(0.5);
      closeText.setVisible(false);
      this.container.add(closeText);

      this.closeButton.on('pointerdown', () => this.close());
      this.closeButtonText = closeText;

      // Start the fishing sequence
      this.startWaitingPhase();

      // Input handling
      this.scene.input.keyboard.on('keydown-SPACE', () => this.onSpacePress());
      this.scene.input.on('pointerdown', () => this.onSpacePress());
    }

    startWaitingPhase() {
      this.state = 'waiting';
      this.instructionText.setText('Wait for the fish to bite...');

      // Animate hook bobbing
      this.scene.tweens.add({
        targets: [this.hook, this.fishingLine],
        y: '+=10',
        duration: 800,
        yoyo: true,
        repeat: -1,
        ease: 'Sine.easeInOut'
      });

      // Random delay before fish bites (1-3 seconds)
      const delay = Phaser.Math.Between(1000, 3000);
      this.hookTimer = this.scene.time.delayedCall(delay, () => {
        this.startHookingPhase();
      });
    }

    startHookingPhase() {
      this.state = 'hooking';
      this.instructionText.setText('‚ùó PRESS SPACE or CLICK NOW! ‚ùó');
      this.instructionText.setFontSize('22px');
      this.instructionText.setStyle({ fill: '#FF0000' });

      // Make hook shake
      this.scene.tweens.killTweensOf([this.hook, this.fishingLine]);
      this.scene.tweens.add({
        targets: [this.hook, this.fishingLine],
        x: '+=5',
        duration: 100,
        yoyo: true,
        repeat: 10
      });

      // Short window to press (1.5 seconds)
      this.hookTimer = this.scene.time.delayedCall(1500, () => {
        if (this.state === 'hooking') {
          this.fail('Too slow!');
        }
      });
    }

    startReelingPhase() {
      this.state = 'reeling';
      this.instructionText.setText('Keep the arrow in the green zone!');
      this.instructionText.setFontSize('18px');
      this.instructionText.setStyle({ fill: '#0F380F' });

      // Select random fish
      const rarityRoll = Math.random();
      let fishPool;
      if (rarityRoll < 0.5) {
        fishPool = FISH_TYPES.filter(f => f.rarity === 'Common');
      } else if (rarityRoll < 0.8) {
        fishPool = FISH_TYPES.filter(f => f.rarity === 'Uncommon');
      } else if (rarityRoll < 0.95) {
        fishPool = FISH_TYPES.filter(f => f.rarity === 'Rare');
      } else {
        fishPool = FISH_TYPES.filter(f => f.rarity === 'Epic');
      }
      this.selectedFish = Phaser.Utils.Array.GetRandom(fishPool);

      // Show arrow UI
      this.arrowContainer.setVisible(true);
      this.progressBar.setVisible(true);
      this.hook.setVisible(false);
      this.fishingLine.setVisible(false);

      // Initialize positions
      this.playerPosition = 0;
      this.targetPosition = Phaser.Math.Between(-100, 100);
      this.targetZone.setX(this.targetPosition);

      // Update loop
      this.reelingTime = 0;
      this.reelingUpdate = this.scene.time.addEvent({
        delay: 50,
        callback: () => this.updateReeling(),
        loop: true
      });
    }

    updateReeling() {
      this.reelingTime += 50;

      // Move target zone randomly
      if (Math.random() < 0.1) {
        this.targetPosition = Phaser.Math.Between(-100, 100);
        this.scene.tweens.add({
          targets: this.targetZone,
          x: this.targetPosition,
          duration: 300,
          ease: 'Sine.easeInOut'
        });
      }

      // Check if player arrow is in target zone
      const distance = Math.abs(this.playerPosition - this.targetPosition);
      const inZone = distance < 40;

      if (inZone) {
        // Progress increases
        const progress = (this.reelingTime / this.maxReelingTime) * 300;
        this.progressBar.setSize(progress, 20);

        if (this.reelingTime >= this.maxReelingTime) {
          this.success();
        }
      } else {
        // Progress decreases
        this.reelingTime = Math.max(0, this.reelingTime - 100);
        const progress = (this.reelingTime / this.maxReelingTime) * 300;
        this.progressBar.setSize(progress, 20);
      }
    }

    onSpacePress() {
      if (this.state === 'hooking') {
        this.startReelingPhase();
      } else if (this.state === 'reeling') {
        // Move player arrow left on press
        this.playerPosition -= 30;
        this.playerPosition = Phaser.Math.Clamp(this.playerPosition, -130, 130);
        this.scene.tweens.add({
          targets: this.playerArrow,
          x: this.playerPosition,
          duration: 100,
          ease: 'Power2'
        });
      }
    }

    success() {
      this.state = 'success';
      this.reelingUpdate.destroy();

      this.instructionText.setText(`üéâ You caught a ${this.selectedFish.displayName}! üéâ`);
      this.instructionText.setFontSize('20px');
      this.instructionText.setStyle({ fill: '#0F380F' });

      this.arrowContainer.setVisible(false);
      this.progressBar.setVisible(false);

      // Show caught fish
      this.resultFish.setTexture('fish', this.selectedFish.id);
      this.resultFish.setVisible(true);

      // Animate fish
      this.resultFish.setScale(0);
      this.scene.tweens.add({
        targets: this.resultFish,
        scale: 6,
        duration: 500,
        ease: 'Back.easeOut'
      });

      // Show rarity
      const rarityText = this.scene.add.text(GAME_WIDTH / 2, GAME_HEIGHT / 2 + 80,
        `[${this.selectedFish.rarity}]`, {
        fontSize: '16px',
        fill: '#0F380F',
        fontStyle: 'italic'
      }).setOrigin(0.5);
      this.container.add(rarityText);

      this.showCloseButton();
    }

    fail(reason) {
      this.state = 'fail';
      if (this.reelingUpdate) this.reelingUpdate.destroy();

      this.instructionText.setText(`‚ùå ${reason}`);
      this.instructionText.setStyle({ fill: '#FF0000' });

      this.arrowContainer.setVisible(false);
      this.progressBar.setVisible(false);
      this.hook.setVisible(false);
      this.fishingLine.setVisible(false);

      this.showCloseButton();
    }

    showCloseButton() {
      this.closeButton.setVisible(true);
      this.closeButtonText.setVisible(true);

      // Hover effect
      this.closeButton.on('pointerover', () => {
        this.closeButton.setFillStyle(0x8BAC0F);
      });
      this.closeButton.on('pointerout', () => {
        this.closeButton.setFillStyle(0x0F380F);
      });
    }

    close() {
      const success = this.state === 'success';
      const fish = success ? this.selectedFish : null;

      // Cleanup
      this.scene.input.keyboard.off('keydown-SPACE');
      if (this.hookTimer) this.hookTimer.destroy();
      if (this.reelingUpdate) this.reelingUpdate.destroy();
      this.container.destroy();

      // Callback
      this.onComplete(success, fish);
    }
  }

  // Player arrow drifts right naturally (using GameState instead of global window)
  setInterval(() => {
    if (GameState.currentFishingGame && GameState.currentFishingGame.state === 'reeling') {
      const game = GameState.currentFishingGame;
      game.playerPosition += 2;
      game.playerPosition = Phaser.Math.Clamp(game.playerPosition, -130, 130);
      game.scene.tweens.add({
        targets: game.playerArrow,
        x: game.playerPosition,
        duration: 50,
        ease: 'Linear'
      });
    }
  }, 50);

  // Make fishing game accessible through GameState for drift mechanic
  const originalCreate = FishingMinigame.prototype.create;
  FishingMinigame.prototype.create = function() {
    GameState.currentFishingGame = this;
    originalCreate.call(this);
  };

  const originalClose = FishingMinigame.prototype.close;
  FishingMinigame.prototype.close = function() {
    GameState.currentFishingGame = null;
    originalClose.call(this);
  };

  // ===== GAME INITIALIZATION =====
  new Phaser.Game({
    type: Phaser.AUTO,
    width: GAME_WIDTH,
    height: GAME_HEIGHT,
    parent: 'game-container',
    backgroundColor: COLORS.SKY,
    scene: TropicalIslandScene,
    scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH },
    render: { pixelArt: true, antialias: false, roundPixels: true }
  });
  </script>
</body>
</html>
